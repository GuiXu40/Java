# -----------------泛型-----------------------
<p id="title"></p>

## 目录
<a href="#p1">:diamonds:为什么要使用泛型</a><br>
<a href="#p2">:diamonds:泛型应用</a><br>
<a href="#p3">:diamonds:泛型的安全警告</a><br>
<a href="#p4">:diamonds:通配符</a><br>
<a href="#p5">:diamonds:泛型与子类继承的限制</a><br>
<a href="#p6">:diamonds:泛型接口</a><br>
<a href="#p7">:diamonds:泛型方法</a><br>
<a href="#p8">:diamonds:泛型数组</a><br>
<a href="#p9">:diamonds:泛型的嵌套设置</a><br>
<a href="#p10">:diamonds:范例--泛型应用</a><br>
<p id="p1"></p>

## :hearts:为什么要使用泛型
<a href="#title">:spades:回到目录</a><br>
为了解决对象强制向下转型所带来的安全隐患-->**解决方法就是不转型,直接利用具体类型进行操作**
<p id="p2"></p>

## :hearts:泛型应用
<a href="#title">:spades:回到目录</a><br>
#### :egg:泛型的基本应用
泛型的主要原理是再类声明的通过一个标识标识类中某个属性的类型或者某个方法的返回值及参数类型
+ 泛型类定义
```Java
[访问权限] class 类名称<泛型类型标识 1,泛型类型标识2,...>{
    [访问权限] 泛型类型标识 变量名称;
    [访问权限] 泛型类型标识 方法名称(){}
}
```
+ 泛型对象定义
```Java
类名称<具体类> 对象名称 = new 类名称<具体类>();
```
例:声明泛型
```Java
public class Point<T> {   //此处可以是任意的标识符号,T是type的简称
    private T var;   //此变量的类型由外部决定
    public T getVar(){
        return var;
    }
    public void setVar(T var){
        this.var=var;     //设置的类型由外部指定
    }
}
```
使用Point类将var设置为整数
```Java
public class Main {
    public static void main(String[] args) {
	// write your code here
        Point<Integer> p=new Point<Integer>();
        p.setVar(20);
        System.out.println(p.getVar());
    }
}
```
在泛型的指定中是无法指定基本数据类型的,必须设置成一个类,这样在设置数字的时候就必须使用包装类(会自定装箱)
<br>
将Point中var设置为string
```Java
public class Main {
    public static void main(String[] args) {
	// write your code here
        Point<String> p=new Point<String>();
        p.setVar("guixu");
        System.out.println(p.getVar());
    }
}
//guixu
```
**如果设置的内容与泛型设定的类型不一致,则会报错**
#### :egg:使用泛型修改代码
使用泛型修改坐标类
```Java
public class Point<T> {   //此处可以是任意的标识符号,T是type的简称
    private T x;
    private T y;
    public T getX(){
        return x;
    }
    public T getY(){
        return y;
    }
    public void setX(T x){
        this.x=x;
    }
    public void setY(T y){
        this.y=y;
    }
}
public class Main {
    public static void main(String[] args) {
	// write your code here
        Point<Integer> p=new Point<Integer>();
        p.setX(10);      //自动装箱
        p.setY(10);
        int x=p.getX();  //自动拆箱
        int y=p.getY();
        System.out.println(x+","+y);
    }
}
//10,10
```
#### :egg:泛型应用中的狗造方法
和之前并无不同
```Java
[访问权限] 构造方法 ([<泛型类型> 参数名称]){}
```
#### :egg:指定多个泛型类型
设置多个泛型类型
```Java
public class Notepad<K,V> {
    private K key;
    private V value;
    public K getKey(){
        return key;
    }
    public V getValue(){
        return value;
    }
    public void setKey(K key){
        this.key=key;
    }
    public void setValue(V value){
        this.value=value;
    }
}
public class Main {
    public static void main(String[] args) {
	// write your code here
        Notepad<String,Integer> t=new Notepad<String,Integer>();
        t.setKey("guixu");
        t.setValue(20);
        System.out.println("key:"+t.getKey()+"value:"+t.getValue());
    }
}
//key:guixuvalue:20
```
<p id="p3"></p>

## :hearts:泛型的安全警告
<a href="#title">:spades:回到目录</a><br>
在泛型应用中,最好在声明类对象时指定号内部的数据类型,会出现警告,但不影响程序的运行
<p id="p4"></p>

## :hearts:通配符
<a href="#title">:spades:回到目录</a><br>
#### :egg:匹配任意类型的通配符
在开发对象的引用传递是最常见的,但是如果在泛型类的操作中,在进行引用传递的泛型类型必须匹配才可以传递,否则无法传递
```Java
public class Info<T> {
    private T var;
    public void setVar(T var) {
        this.var = var;
    }
    public T getVar() {
        return var;
    }
}
public class Main {
    public static void main(String[] args) {
	// write your code here
        Info<String> i=new Info<String>();
        i.setVar("guixu");
        fun(i)
    }
    public static void fun(Info<Object> temp){
        System.out.println(temp);
    }
}

```
在上面的程序中尽管String是Object类的子类,但在进行引用传递时也同样无法进行操作,如果想让程序正常执行,可以不指定泛型
```Java
public class Main {
    public static void main(String[] args) {
	// write your code here
        Info<String> i=new Info<String>();
        i.setVar("guixu");
        fun(i)
    }
    public static void fun(Info temp){
        System.out.println(temp);
    }
}
```
也可以使用通配符"?",表示可以接受任意泛型对象
```Java
public class Main {
    public static void main(String[] args) {
	// write your code here
        Info<String> i=new Info<String>();
        i.setVar("guixu");
        fun(i)
    }
    public static void fun(Info<?> temp){
        System.out.println(temp);
    }
}
```
**注意**: 如果使用"?"接收泛型对象时,则不能设置被泛型指定的内容
```Java
  public static void main(String[] args) {
	// write your code here
        Info<?> i=new Info<String>();
        i.setVar("guixu");
        //报错,可以设置为null
    }
```
#### :egg:受限泛型
<p id="p5"></p>

## :hearts:泛型与子类继承的限制
<a href="#title">:spades:回到目录</a><br>
<p id="p6"></p>

## :hearts:泛型接口
<a href="#title">:spades:回到目录</a><br>
#### :egg:定义泛型接口
#### :egg:泛型接口的两种实现方式
<p id="p7"></p>

## :hearts:泛型方法
<a href="#title">:spades:回到目录</a><br>
#### :egg:定义泛型方法
#### :egg:通过泛型方法返回泛型类型
#### :egg:使用泛型统一传入的参数类型
<p id="p8"></p>

## :hearts:泛型数组
<a href="#title">:spades:回到目录</a><br>
<p id="p9"></p>

## :hearts:泛型的嵌套设置
<a href="#title">:spades:回到目录</a><br>
<p id="p10"></p>

## :hearts:范例--泛型应用
<a href="#title">:spades:回到目录</a><br>
