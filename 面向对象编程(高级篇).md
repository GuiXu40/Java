# -----------------面向对象(高级篇)-------------------------
<p id="title"></p>

## 目录
<a href="#p1">:diamonds:继承的基本概念</a><br>
<a href="#p2">:diamonds:继承深入</a><br>
<a href="#p3">:diamonds:继承的应用</a><br>
<a href="#p4">:diamonds:final关键字</a><br>
<a href="#p5">:diamonds:抽象类的基本概念</a><br>
<a href="#p6">:diamonds:接口的基本概念</a><br>
<a href="#p7">:diamonds:对象的多态性</a><br>
<a href="#p8">:diamonds:instanceof关键字</a><br>
<a href="#p9">:diamonds:抽象类与接口的应用</a><br>
<a href="#p10">:diamonds:实例分析--宠物商店</a><br>
<a href="#p11">:diamonds:Object类</a><br>
<a href="#p12">:diamonds:包装类</a><br>
<a href="#p13">:diamonds:匿名内部类</a><br>
<p id="p1"></p>

## :hearts:继承的基本概念
<a href="#title">:spades:回到目录</a><br>
类的继承语法
```Java
class 父类{}  //定义父类
class 子类 extends 父类{}  //使用extends关键字
```
例:学生类继承人类
```Java
public class Person{
    private String name;
    private int age;
    public String getName(){
        return name;   //取得名字
    }
    public void setName(String n){
        name=n;       //设置姓名
    }
    public int getAge(){
        return age;   //取得年龄
    }
    public void setAge(int n){
        age=n;      //设置年龄
    }
    public void tell(){
        System.out.println("姓名："+name+",年龄："+age);
    }
}
class Student extends Person{
    private String school;
    public String getSchool(){
        return school;
    }
    public void setSchool(String s){
        school=s;
    }
}
public class Main {
    public static void main(String args[]){
        Student s=new Student();
        s.setName("guixu");
        s.setAge(18);
        s.setSchool("zhaojia");
        System.out.println("姓名:"+s.getName()+"年龄:"+s.getAge()+"学校:"+s.getSchool());
    }
}
//姓名:guixu年龄:18学校:zhaojia
```
**注意**: 子类是不能直接访问父类中的私有变量的,但是子类可以调用非私有方法,只允许多层继承不允许多重继承--(一个子类只能有一个父类)
<p id="p1"></p>

## :hearts:继承深入
<a href="#title">:spades:回到目录</a><br>
#### :egg:子类对象的实例化过程
子类对象在实例化之前必须调用父类中的构造方法之后在调用子类自己的构造方法
```Java
public class Person{
    private String name;
    private int age;
    public Person(){
        System.out.println("父类中的构造方法");
    }
    public String getName(){
        return name;   //取得名字
    }
    public void setName(String n){
        name=n;       //设置姓名
    }
    public int getAge(){
        return age;   //取得年龄
    }
    public void setAge(int n){
        age=n;      //设置年龄
    }
    public void tell(){
        System.out.println("姓名："+name+",年龄："+age);
    }
}
class Student extends Person{
    private String school;
    public Student(){
        System.out.println("子类中的构造方法");
    }
    public String getSchool(){
        return school;
    }
    public void setSchool(String s){
        school=s;
    }
}
public class Main {
    public static void main(String args[]){
        Student s=new Student();
        s.setName("guixu");
        s.setAge(18);
        s.setSchool("zhaojia");
       // System.out.println("姓名:"+s.getName()+"年龄:"+s.getAge()+"学校:"+s.getSchool());
    }
}
//父类中的构造方法
//子类中的构造方法
```
对于以上的代码其实在子类的构造方法中隐藏了一个super()的语法,代码如下
```Java
class Student extends Person{
    private String school;
    public Student(){
        super();       //加与不加此语句效果一样
        System.out.println("子类中的构造方法");
    }
    public String getSchool(){
        return school;
    }
    public void setSchool(String s){
        school=s;
    }
}
```
#### :egg:方法的覆写
方法覆写就是在子类中定义了与父类中同名的方法,但**子类覆写的方法不能拥有比父类方法更加严格的访问权限:权限大小关系:private<default<public**,而且在子类中
可以直接通过**super.方法()** 的形式来访问父类中的方法
```Java
public class Person{
    public void print(){
        System.out.println("person");
    }
}
class Student extends Person{
    public void print(){
        super.print();         //调用父类的print方法
        System.out.println("Student");
    }
}
public class Main {
    public static void main(String args[]){
        Student s=new Student();
        s.print();
    }
}
//person
//Student
```
------注意:
方法覆写时从private变为default不是方法覆写,而是在子类中重写定义了一个方法
```Java
public class Person{
    private void print(){
        System.out.println("person");
    }
    public void fun(){
        this.super();
    }
}
class Student extends Person{
    public void print(){
        super.print();         //调用父类的print方法
        System.out.println("Student");
    }
}
public class Main {
    public static void main(String args[]){
        Student s=new Student();
        s.fun();
    }
}
//person
```

---
除了方法的覆用也有属性的覆用:*子类如果和父类声明了相同名称和属性,则在子类中直接访问的时候采用"就近访问原则",先找到本类中的属性,要调用父类的属性,直接使用super.属性就可以了*
#### :egg:super关键字的作用
使用super可以从子类中调用父类中的构造方法,普通方法,属性,但是语句必须放在子类构造方法的首行
```Java
class Person{
    private String name;
    private int age;
    public Person(String name,int age){
        this.setName(name);
        this.setAge(age);
    }
    public String getName(){
        return name;   //取得名字
    }
    public void setName(String n){
        name=n;       //设置姓名
    }
    public int getAge(){
        return age;   //取得年龄
    }
    public void setAge(int n){
        age=n;      //设置年龄
    }
    public String tell(){
        return "xingming:"+this.getName()+"age:"+this.getAge();
    }
}
class Student extends Person{
    private String school;
    public Student(String name,int age,String school){
        super(name, age);
        this.setSchool(school);
    }
    public String getSchool(){
        return school;
    }
    public void setSchool(String s){
        school=s;
    }
    public String tell(){
        return super.tell()+"school:"+this.getSchool();
    }
}
public class Main {
    public static void main(String args[]){
        Student s=new Student("guixu",18,"aaa");
        System.out.println(s.tell());
    }
}
//xingming:guixuage:18school:aaa
```
this与super的区别

区别点|this|super
---|:--:|:--:
属性访问|访问本类中的属性,如果没有则从父类中寻找|访问父类中的属性
方法|访问本类中的方法,如果没有,则从父类中继续寻找|访问父类的属性
调用构造|调用本类构造,必须放在构造方法的首行|调用父类构造,必须放在子类构造方法的首行
特殊|表示当前对象|无此概念

**注意**: super和this不能同时出行,因为都要放在首行
<p id="p2"></p>

## :hearts:继承的应用
<a href="#title">:spades:回到目录</a><br>
<p id="p3"></p>

## :hearts:final关键字
<a href="#title">:spades:回到目录</a><br>
<p id="p4"></p>

## :hearts:抽象类的基本概念
<a href="#title">:spades:回到目录</a><br>
<p id="p5"></p>

## :hearts:接口的基本概念
<a href="#title">:spades:回到目录</a><br>
<p id="p6"></p>

## :hearts:对象的多态性
<a href="#title">:spades:回到目录</a><br>
<p id="p7"></p>

## :hearts:instanceof关键字
<a href="#title">:spades:回到目录</a><br>
<p id="p8"></p>

## :hearts:抽象类与接口的应用
<a href="#title">:spades:回到目录</a><br>
#### :egg:为抽象类与接口实例化
#### :egg:抽象类的实际应用--模板设计
#### :egg:接口的实际应用--制定标准
#### :egg:设计模式--工厂设计
#### :egg:设计模式--代理设计
#### :egg:设计模式--适配器设置
#### :egg:内部类的拓展
#### :egg:抽象类与接口之间的关系
#### :egg:接口定义加强
<p id="p9"></p>

## :hearts:实例分析--宠物商店
<a href="#title">:spades:回到目录</a><br>
<p id="p11"></p>

## :hearts:Object类
<a href="#title">:spades:回到目录</a><br>
#### :egg:基本作用
#### :egg:主要方法
#### :egg:接收任意引用类型的对象
<p id="p12"></p>

## :hearts:包装类
<a href="#title">:spades:回到目录</a><br>
#### :egg:包装类的介绍
#### :egg:装箱与拆箱
#### :egg:包装类应用
<p id="p13"></p>

## :hearts:匿名内部类
<a href="#title">:spades:回到目录</a><br>
