# -----------------面向对象(高级篇)-------------------------
<p id="title"></p>

## 目录
<a href="#p1">:diamonds:继承的基本概念</a><br>
<a href="#p2">:diamonds:继承深入</a><br>
<a href="#p3">:diamonds:继承的应用</a><br>
<a href="#p4">:diamonds:final关键字</a><br>
<a href="#p5">:diamonds:抽象类的基本概念</a><br>
<a href="#p6">:diamonds:接口的基本概念</a><br>
<a href="#p7">:diamonds:对象的多态性</a><br>
<a href="#p8">:diamonds:instanceof关键字</a><br>
<a href="#p9">:diamonds:抽象类与接口的应用</a><br>
<a href="#p10">:diamonds:实例分析--宠物商店</a><br>
<a href="#p11">:diamonds:Object类</a><br>
<a href="#p12">:diamonds:包装类</a><br>
<a href="#p13">:diamonds:匿名内部类</a><br>
<p id="p1"></p>

## :hearts:继承的基本概念
<a href="#title">:spades:回到目录</a><br>
类的继承语法
```Java
class 父类{}  //定义父类
class 子类 extends 父类{}  //使用extends关键字
```
例:学生类继承人类
```Java
public class Person{
    private String name;
    private int age;
    public String getName(){
        return name;   //取得名字
    }
    public void setName(String n){
        name=n;       //设置姓名
    }
    public int getAge(){
        return age;   //取得年龄
    }
    public void setAge(int n){
        age=n;      //设置年龄
    }
    public void tell(){
        System.out.println("姓名："+name+",年龄："+age);
    }
}
class Student extends Person{
    private String school;
    public String getSchool(){
        return school;
    }
    public void setSchool(String s){
        school=s;
    }
}
public class Main {
    public static void main(String args[]){
        Student s=new Student();
        s.setName("guixu");
        s.setAge(18);
        s.setSchool("zhaojia");
        System.out.println("姓名:"+s.getName()+"年龄:"+s.getAge()+"学校:"+s.getSchool());
    }
}
//姓名:guixu年龄:18学校:zhaojia
```
**注意**: 子类是不能直接访问父类中的私有变量的,但是子类可以调用非私有方法,只允许多层继承不允许多重继承--(一个子类只能有一个父类)
<p id="p1"></p>

## :hearts:继承深入
<a href="#title">:spades:回到目录</a><br>
#### :egg:子类对象的实例化过程
子类对象在实例化之前必须调用父类中的构造方法之后在调用子类自己的构造方法
```Java
public class Person{
    private String name;
    private int age;
    public Person(){
        System.out.println("父类中的构造方法");
    }
    public String getName(){
        return name;   //取得名字
    }
    public void setName(String n){
        name=n;       //设置姓名
    }
    public int getAge(){
        return age;   //取得年龄
    }
    public void setAge(int n){
        age=n;      //设置年龄
    }
    public void tell(){
        System.out.println("姓名："+name+",年龄："+age);
    }
}
class Student extends Person{
    private String school;
    public Student(){
        System.out.println("子类中的构造方法");
    }
    public String getSchool(){
        return school;
    }
    public void setSchool(String s){
        school=s;
    }
}
public class Main {
    public static void main(String args[]){
        Student s=new Student();
        s.setName("guixu");
        s.setAge(18);
        s.setSchool("zhaojia");
       // System.out.println("姓名:"+s.getName()+"年龄:"+s.getAge()+"学校:"+s.getSchool());
    }
}
//父类中的构造方法
//子类中的构造方法
```
对于以上的代码其实在子类的构造方法中隐藏了一个super()的语法,代码如下
```Java
class Student extends Person{
    private String school;
    public Student(){
        super();       //加与不加此语句效果一样
        System.out.println("子类中的构造方法");
    }
    public String getSchool(){
        return school;
    }
    public void setSchool(String s){
        school=s;
    }
}
```
#### :egg:方法的覆写
方法覆写就是在子类中定义了与父类中同名的方法,但**子类覆写的方法不能拥有比父类方法更加严格的访问权限:权限大小关系:private<default<public**,而且在子类中
可以直接通过**super.方法()** 的形式来访问父类中的方法
```Java
public class Person{
    public void print(){
        System.out.println("person");
    }
}
class Student extends Person{
    public void print(){
        super.print();         //调用父类的print方法
        System.out.println("Student");
    }
}
public class Main {
    public static void main(String args[]){
        Student s=new Student();
        s.print();
    }
}
//person
//Student
```
------注意:
方法覆写时从private变为default不是方法覆写,而是在子类中重写定义了一个方法
```Java
public class Person{
    private void print(){
        System.out.println("person");
    }
    public void fun(){
        this.super();
    }
}
class Student extends Person{
    public void print(){
        super.print();         //调用父类的print方法
        System.out.println("Student");
    }
}
public class Main {
    public static void main(String args[]){
        Student s=new Student();
        s.fun();
    }
}
//person
```

---
除了方法的覆用也有属性的覆用:*子类如果和父类声明了相同名称和属性,则在子类中直接访问的时候采用"就近访问原则",先找到本类中的属性,要调用父类的属性,直接使用super.属性就可以了*
#### :egg:super关键字的作用
使用super可以从子类中调用父类中的构造方法,普通方法,属性,但是语句必须放在子类构造方法的首行
```Java
class Person{
    private String name;
    private int age;
    public Person(String name,int age){
        this.setName(name);
        this.setAge(age);
    }
    public String getName(){
        return name;   //取得名字
    }
    public void setName(String n){
        name=n;       //设置姓名
    }
    public int getAge(){
        return age;   //取得年龄
    }
    public void setAge(int n){
        age=n;      //设置年龄
    }
    public String tell(){
        return "xingming:"+this.getName()+"age:"+this.getAge();
    }
}
class Student extends Person{
    private String school;
    public Student(String name,int age,String school){
        super(name, age);
        this.setSchool(school);
    }
    public String getSchool(){
        return school;
    }
    public void setSchool(String s){
        school=s;
    }
    public String tell(){
        return super.tell()+"school:"+this.getSchool();
    }
}
public class Main {
    public static void main(String args[]){
        Student s=new Student("guixu",18,"aaa");
        System.out.println(s.tell());
    }
}
//xingming:guixuage:18school:aaa
```
this与super的区别

区别点|this|super
---|:--:|:--:
属性访问|访问本类中的属性,如果没有则从父类中寻找|访问父类中的属性
方法|访问本类中的方法,如果没有,则从父类中继续寻找|访问父类的属性
调用构造|调用本类构造,必须放在构造方法的首行|调用父类构造,必须放在子类构造方法的首行
特殊|表示当前对象|无此概念

**注意**: super和this不能同时出行,因为都要放在首行
<p id="p2"></p>

## :hearts:继承的应用
<a href="#title">:spades:回到目录</a><br>
定义一个整形数组类,要求包含构造方法,增加数据及输出数据成员,并定义子类:排序类,反转类
```Java
public class Array {
    private int temp[];
    private int foot;
    public Array(int len){
        if(len>0){
            this.temp=new int[len];
        }else{
            this.temp=new int[1];
        }
    }
    public boolean add(int i){
        if(this.foot<this.temp.length){
            this.temp[foot]=i;
            foot++;
            return true;
        }else{
            return false;
        }
    }
    public int[] getArray(){
        return this.temp;
    }
}
public class ReverseArray extends Array{
    public ReverseArray(int len){
        super(len);
    }
    public int[] getArray(){
        int center = super.getArray().length/2;
        int head=0;
        int tail=super.getArray().length-1;
        for(int x=0;x<center;x++){
            int temp=super.getArray()[head];
            super.getArray()[head]=super.getArray()[tail];
            super.getArray()[tail]=temp;
            head++;
            tail--;
        }
        return super.getArray();
    }
}
public class SortArray extends Array{
    public SortArray(int len){
        super(len);
    }
    public int[] getArray(){
        java.util.Arrays.sort(super.getArray());
        return super.getArray();
    }
}
//反转
public class Main {
    public static void main(String args[]){
        ReverseArray a=new ReverseArray(5);
        System.out.print(a.add(11)+"\t");
        System.out.print(a.add(22)+"\t");
        System.out.print(a.add(33)+"\t");
        System.out.print(a.add(44)+"\t");
        System.out.print(a.add(55)+"\t");
        System.out.print(a.add(66)+"\t");
        print(a.getArray());
    }
    public static void print(int i[]){
        for(int x=0;x<i.length;x++){
            System.out.print(i[x]+",");
        }
    }
}
//true	true	true	true	true	false	55,44,33,22,11,
//排序
public class Main {
    public static void main(String args[]){
        SortArray a=new SortArray(5);
        System.out.print(a.add(11)+"\t");
        System.out.print(a.add(22)+"\t");
        System.out.print(a.add(5)+"\t");
        System.out.print(a.add(44)+"\t");
        System.out.print(a.add(7)+"\t");
        System.out.print(a.add(66)+"\t");
        print(a.getArray());
    }
    public static void print(int i[]){
        for(int x=0;x<i.length;x++){
            System.out.print(i[x]+",");
        }
    }
}
//true	true	true	true	true	false	5,7,11,22,44,
```
<p id="p3"></p>

## :hearts:final关键字
<a href="#title">:spades:回到目录</a><br>
final:完结器,注意事项:
+ 使用final声明的类不能有子类
+ 使用final声明的方法不能被子类覆盖
+ 使用final声明的变量即成为常量,不可以修改
<p id="p4"></p>

## :hearts:抽象类的基本概念
<a href="#title">:spades:回到目录</a><br>
抽象类的左右类似于"模板",其目的是要设计者依据它的格式来修改并创建新的类,但是并不能直接由抽象类创建对象,只能通过抽象类派生出新的类,再由他来创建对象,一个子类只能继承一个抽象类
+ 包含一个抽象方法的必须是抽象类
+ 抽象类和方法都要使用abstract关键字声明
+ 抽象方法只需要声明而不需要实现
+ 抽象类必须被子类继承,子类(如果不是抽象类)必须覆写抽象类中的全部抽象方法
+ 抽象类不可以使用final关键字
+ 抽象方法不能使用private,因为抽象方法必须被子类覆写
+ 在一个抽象类中是允许存在构造方法的,子类在实例化之前肯定是要对父类进行实例化的
<p id="p5"></p>

## :hearts:接口的基本概念
<a href="#title">:spades:回到目录</a><br>
接口可以理解为一种特殊的类,里面全部是由全局变量和公共的抽象方法所组成,定义格式
```Java
interface 接口名称{
    全局常量;
    抽象方法;
}
```
**在接口中的抽象方法必须定义成public访问权限,绝对不可以改变,如果不写,默认为public**<br>
实现接口,子类通过implements关键字实现接口
```Java
class 类名 implements 接口A,接口B,...{
}
```
一个子类可以同时实现多个接口,实现接口
```Java
public interface A {
    public String Author="guixu";
    public void print();
    public String getInfo();
}
public interface B {
    public void say();
}
public class X implements A,B{
    public void say(){
        System.out.println("hello");
    }
    public String getInfo(){
        return "hello";
    }
    public void print(){
        System.out.println("author:"+Author);
    }
}
public class Main {
    public static void main(String args[]){
        X x=new X();
        x.say();
        x.print();
    }
}
//hello
//author:guixu
```
上面的代码中,一个子类实现了两个接口,就必须覆写完连个接口中的全部抽象方法
<br>
一个类可以即实现接口,有继承抽象类
```Java
class 子类 extends 抽象类 implements 接口A,接口B,...{
}
```
抽象类也是可以实现多个接口的,接口不允许继承抽象类,但是接口可以继承多个接口
<p id="p6"></p>

## :hearts:对象的多态性
<a href="#title">:spades:回到目录</a><br>
在Java中多态有两种体现方式:
+ 方法的重载与覆写
+ 对象的多态性

<br>

对象的多态性分为以下两种类型:向上转型: 子类对象->父类实例   向下转型: 父类对象-> 子类实例
<br>
对于向上转型,程序会自动完成,对于向下转型,必须指明要转型的子类类型:格式
```Java
向上转型: 父类 父类对象 = 子类实例
向下转型: 子类 子类对象 = (子类)父类实例
```
对象的向上转型:
```Java
public class A {
    public void fun1(){
        System.out.println("A--fun1");
    }
    public void fun2(){
        this.fun1();
    }
}
public class B extends A{
    public void fun1(){
        System.out.println("B--fun1");
    }
    public void fun3(){
        System.out.println("B--fun3");
    }
}
public class Main {
    public static void main(String args[]){
        B b=new B();
        A a=b;
        a.fun1();
    }
}
//B--fun1
```
虽然是使用父类对象调用了fun1()方法,但实际上调用的方法是被子类覆写过的方法,而且a对象无法调用B类的fun3()方法<br>
向下转型:
```Java
public class A {
    public void fun1(){
        System.out.println("A--fun1");
    }
    public void fun2(){
        this.fun1();
    }
}
public class B extends A{
    public void fun1(){
        System.out.println("B--fun1");
    }
    public void fun3(){
        System.out.println("B--fun3");
    }
}
public class Main {
    public static void main(String args[]){
        A a=new B();    //发生了向上转型的关系,子类-->父类
        B b=(B)a;         //向下转型
        b.fun1();
        b.fun2();
        b.fun3();
    }
}
```
**注意**: 在进行对象的向下转型之前,必须首先发生对象向上转型,否则报错
<br>
对象多态性的作用:利用对象多态性实现一个方法,此方法可以接受A类的任意子类对象
```Java
public class A {
    public void fun1(){
        System.out.println("A--fun1");
    }
    public void fun2(){
        this.fun1();
    }
}
public class B extends A{
    public void fun1(){
        System.out.println("B--fun1");
    }
    public void fun3(){
        System.out.println("B--fun3");
    }
}
public class C extends A{
    public void fun1(){
        System.out.println("c--fun1");
    }
    public void fun5(){
        System.out.println("c--fun3");
    }
}
public class Main {
    public static void main(String args[]){
        fun(new B());
        fun(new C());
    }
    public static void fun(A a){
        a.fun1();
    }
}
//B--fun1
//c--fun1
```
在fun()方法中使用了对象的多态性,所以可以接受任何子类对象,这样不管子类如何增加,则fun()方法都可以不做改变,因为一旦发生对象的向上转型之后,调用的方法肯定是被子类覆写的方法
<p id="p7"></p>

## :hearts:instanceof关键字
<a href="#title">:spades:回到目录</a><br>
使用instanceof关键字判断一个对象到底是那个类的实例
```Java
对象 instanceof 类 ->返回 boolean类型
```
实例:
```Java
public class A {
    public void fun1(){
        System.out.println("A--fun1");
    }
    public void fun2(){
        this.fun1();
    }
}
public class B extends A{
    public void fun1(){
        System.out.println("B--fun1");
    }
    public void fun3(){
        System.out.println("B--fun3");
    }
}
public class Main {
    public static void main(String args[]){
        A a1=new B();
        System.out.println((a1 instanceof A));
        System.out.println((a1 instanceof B));
        A a2=new A();
        System.out.println((a2 instanceof A));
        System.out.println((a2 instanceof B));
    }
}
//true
//true
//true
//false
```
<p id="p8"></p>

## :hearts:抽象类与接口的应用
<a href="#title">:spades:回到目录</a><br>
#### :egg:为抽象类与接口实例化
#### :egg:抽象类的实际应用--模板设计
#### :egg:接口的实际应用--制定标准
#### :egg:设计模式--工厂设计
#### :egg:设计模式--代理设计
#### :egg:设计模式--适配器设置
#### :egg:内部类的拓展
#### :egg:抽象类与接口之间的关系
#### :egg:接口定义加强
<p id="p9"></p>

## :hearts:实例分析--宠物商店
<a href="#title">:spades:回到目录</a><br>
<p id="p11"></p>

## :hearts:Object类
<a href="#title">:spades:回到目录</a><br>
#### :egg:基本作用
#### :egg:主要方法
#### :egg:接收任意引用类型的对象
<p id="p12"></p>

## :hearts:包装类
<a href="#title">:spades:回到目录</a><br>
#### :egg:包装类的介绍
#### :egg:装箱与拆箱
#### :egg:包装类应用
<p id="p13"></p>

## :hearts:匿名内部类
<a href="#title">:spades:回到目录</a><br>
